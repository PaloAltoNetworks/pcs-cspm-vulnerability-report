import os
import urllib3
import json
import sys
import gzip
import pandas
import os

#Vulnerabilties Parameters
"""
    Possible Values
    SEVERITIES:
    - High
    - Critical
    - Medium
    - Low
    - Informational
    SEVERITIES_OPERATION:
    - IN
    - IS
    RISK_FACTORS:
    - Attack Complexity: Low
    - Attack Vector: Network
    - Container Is Running As Root
    - Critical Severity
    - Denial Of Service
    - Dos - High
    - Dos - Low
    - Exploit Exists - Poc
    - Exploit Exists - In The Wild
    - Exploitable
    - Has Fix
    - High Severity
    - Host Access
    - Internet Exposed
    - Listening Ports
    - Medium Severity
    - No Mandatory Security Profile Applied
    - Package In Use
    - Patchable
    - Recent Vulnerability
    - Remote Execution
    - Root Mount
    - Running As Privileged Container
    - Runtime Socket
    - Sensitive Information
    - Urgent
    RISK_FACTORS_OPERATION:
    - CONTAINS ALL (AND operation)
    - IN (OR operation)
"""

#Set default vulnerabilities query
# Example using previous parameters
## vulns_query = f"vulnerability where severity {SEVERITIES_OPERATION} {SEVERITIES} AND risk.factors {RISK_FACTORS_OPERATION} {RISK_FACTORS}"
vulns_query = f"vulnerability where severity IN ( 'High', 'Critical' ) AND risk.factors CONTAINS ALL ( 'Exploitable', 'Patchable', 'Internet Exposed' )"

if os.path.exists(".env"):
    from dotenv import load_dotenv
    load_dotenv()

#Compute API parameters 
PRISMA_API_ENDPOINT = os.getenv("PRISMA_API_ENDPOINT", "https://api.prismacloud.io")
PRISMA_USERNAME = os.getenv("PRISMA_USERNAME", "")
PRISMA_PASSWORD = os.getenv("PRISMA_PASSWORD", "")
QUERY = os.getenv("QUERY", vulns_query) # This value can be any query created in Prisma Cloud
OWNER_TAG = os.getenv("OWNER_TAG", "owner").lower()
OUT_FILE = os.getenv("OUT_FILE", "vulnerabilities_report.csv").lower()
NOT_FOUND = os.getenv("NOT_FOUND", "notFound.json")


http = urllib3.PoolManager()

def http_request(api_endpoint, path, body={}, method="POST"):
    global headers
    if body:
        response = http.request(method, f"{api_endpoint}{path}", headers=headers, body=json.dumps(body))
    else:
        response = http.request(method, f"{api_endpoint}{path}", headers=headers)

    if response.status == 200:
        return response.data
    
    if response.status == 404:
        with open(NOT_FOUND) as not_found:
            return not_found.read()
    
    if response.status == 401 and path not in ("/login", "/api/v1/authenticate"):
        token_body = {
            "username": PRISMA_USERNAME,
            "password": PRISMA_PASSWORD
        }
        if "X-Redlock-Auth" in headers:
            token = json.loads(http_request(PRISMA_API_ENDPOINT, "/login", token_body))["token"]
            headers["X-Redlock-Auth"] = token
        else:
            token = json.loads(http_request(PRISMA_API_ENDPOINT, "/api/v1/authenticate", token_body))["token"]
            headers["Authentication"] = f"Bearer {token}"
            
        return http_request(PRISMA_API_ENDPOINT, path, body)
    
    print(f"Error making request to path {path}. Body: {body}. Error message: {response.data}. Status code: {response.status}")
    sys.exit(2)

if __name__ == "__main__":
    
    #Retrieve Console Token
    headers = {
        "Content-Type": "application/json",
        "Accept": "*/*"
    }
    token_body = {
        "username": PRISMA_USERNAME,
        "password": PRISMA_PASSWORD
    }

    auth_content = json.loads(http_request(PRISMA_API_ENDPOINT, "/login", token_body))
    token = auth_content["token"]
    prisma_id = auth_content["customerNames"][0]["prismaId"]
    headers["X-Redlock-Auth"] = token

    # Get the vulnerabilities report based on the query
    body = {
        "query": QUERY
    }

    vuln_data_zipped = http_request(PRISMA_API_ENDPOINT, "/uve/api/v1/vulnerabilities/search/download", body)

    with open("tmp.gzip", "wb") as tmp_file:
        tmp_file.write(vuln_data_zipped)

    with gzip.open("tmp.gzip", "rb") as tmp_file:
        with open("tmp.csv", "wb") as tmp_csv:
            tmp_csv.write(tmp_file.read())

    vuln_data = pandas.read_csv("tmp.csv")
    asset_ids = vuln_data["ASSET_ID"]
    unique_asset_ids = asset_ids.unique()
    assets_region = {}
    assets_url = {}
    assets_name = {}
    assets_cluster = {}
    assets_repo = {}
    assets_owner = {}
    assets_branch = {}
    assets_filepath = {}
    assets_tags = {}

    for asset_id in unique_asset_ids:
        asset_csv_info = vuln_data.loc[asset_ids == asset_id]
        asset_type = asset_csv_info["ASSET_TYPE"].iloc[0]

        if asset_type in ("iac", "package"):
            asset_cve = asset_csv_info["CVE_ID"].iloc[0]
            body = {
                "cveId": asset_cve,
                "assetIds": [asset_id],
                "prismaId": prisma_id
            }
            asset_data = json.loads(http_request(PRISMA_API_ENDPOINT, "/uve/api/v1/asset-details", body))["value"][0]
            assets_name[asset_id] = asset_data["assetName"]
            assets_repo[asset_id] = asset_data["repositoryName"]
            assets_filepath[asset_id] = asset_data["filePath"]
            assets_url[asset_id] = asset_data["repoUrl"]
            assets_owner[asset_id] = asset_data["owner"]
            assets_branch[asset_id] = asset_data["branch"]

        else:
            body = {
                "type": "asset_lite",
                "assetId": asset_id
            }
            asset_data = json.loads(http_request(PRISMA_API_ENDPOINT, "/uai/v1/asset", body))["data"]["asset"]
            deleted = asset_data["deleted"]

            if deleted:
                vuln_data = vuln_data.drop(vuln_data[vuln_data["ASSET_ID"] == asset_id].index)
                continue

#            if "problem" in asset_data["attributes"]:
#                if asset_data["attributes"]["problem"]["status"] == 404:
#                    vuln_data = vuln_data.drop(vuln_data[vuln_data["ASSET_ID"] == asset_id].index)
#                    continue

                             

            assets_name[asset_id] = asset_data["name"]
            if OWNER_TAG in asset_data["tags"]:
                assets_owner[asset_id] = asset_data["tags"].pop(OWNER_TAG)
                

            assets_tags[asset_id] = asset_data["tags"]

            if "cluster" in asset_data["attributes"]: assets_cluster[asset_id] = asset_data["attributes"]["cluster"]
            if "regionId" in asset_data: assets_region[asset_id] = asset_data["regionId"]
            if "url" in asset_data: 
                url = asset_data["url"]
                if url:
                    if url[32:38] == "https:":
                        url = url[32:]
                    assets_url[asset_id] = url
        
    vuln_data["REGION"] = vuln_data["ASSET_ID"].map(assets_region)
    vuln_data["CLUSTER"] = vuln_data["ASSET_ID"].map(assets_cluster)
    vuln_data["ASSET_REPO"] = vuln_data["ASSET_ID"].map(assets_repo)
    vuln_data["ASSET_OWNER"] = vuln_data["ASSET_ID"].map(assets_owner)
    vuln_data["ASSET_BRANCH"] = vuln_data["ASSET_ID"].map(assets_branch)
    vuln_data["ASSET_FILEPATH"] = vuln_data["ASSET_ID"].map(assets_filepath)
    vuln_data["ASSET_TAGS"] = vuln_data["ASSET_ID"].map(assets_tags)
    vuln_data["ASSET_URL"] = vuln_data["ASSET_ID"].map(assets_url)
    vuln_data["ASSET_ID"] = vuln_data["ASSET_ID"].replace(assets_name)

    vuln_data.to_csv(OUT_FILE)
    os.remove("tmp.csv")
    os.remove("tmp.gzip")